=begin
This  is my solution using ruby. It is composed of one class, the BoxImage class. The method that does all the magic is the find_boxes method. It has a default parameter of two, so it will look for squares(which happen to be rectangles) which have two columns of zeroes.  If you pass in a parameter of three, it finds rectangles with three columns of zeroes. It always assumes the rectangles have two rows, which is a weakness in the algorithm as a rectangle could have more than two rows. I also tried to create a method that would raise an exception if the rectangles are not seperated by more than one pixel. I could not get this working in the time constraints given. The time complexity is O(n3). I had problems copying the raised three here for some reason. There is technically only one loop that depends on the input. That is the loop in check_next_row which is in find_boxes. However, the speed of the program depends on the size of the image array. I chose to store that in an instance variable which I initialize in the initialize method. There are two nested loops in
find_boxes which are dependent on the size of this array. That is why I said O(n3), for three nested loops, even though the image array is not passed into the find_boxes method. I pass the image array as a paramter to def initialize which creates an instance of BoxImage. 
=end
# finds a box image
class BoxImage
  attr_accessor :my_image, :counter, :my_array
  def initialize(image)
    @my_image = image
    @my_array = []
    @counter = 0
  end

  def find_boxes(num_column = 2)
    @my_image.each.with_index do |coordinates, row_index|
      coordinates.each.with_index do |item, col_index|
      change_counter(item)
      if @counter == num_column
        if check_next_row(col_index,row_index,num_column)
           fetch_coordinates(col_index,row_index, num_column)
           @counter = 0
         end
        end
     end
    end
   # check_pixels @my_array
    print_coordinates @my_array
  end

  def change_counter(item)
    if item == 0
      @counter += 1
    else
      @counter = 0
    end
  end

  def check_next_row(col_index,row_index, num_col)
    check_next = true
    next_row = row_index + 1
    if row_index != 7
      for i in 0..num_col - 1
        if @my_image[next_row][col_index - i] != 0
          check_next = false
        end
      end
    end
    check_next
  end
  
   def check_pixels(coordinates_array)
       for i in 0..coordinates_array.size-1 
        if i <  4
         compare_array(coordinates_array[i+1],coordinates_array[i])
       end
      end
  end
  
  def compare_array(end_coordinate_array,begin_coordinate_array)
      if begin_coordinate_array[1][0] == end_coordinate_array[0][0]
         if end_coordinate_array[0][1] - begin_coordinate_array[1][1] == 1
          raise RuntimeError, "The rectangle with the coordinates row: #{end_coordinate_array[0][0]} and column: #{end_coordinate_array[0][1]} is not separated by a pixel"
         end 
     end
  end

  def fetch_coordinates(col_index,row_index,num_col)
     i = col_index + 1 - num_col
     next_row = row_index + 1
     if row_index != 7
       @my_array << [[i , row_index], [col_index , row_index], [i, next_row], [col_index, next_row]]
     end
  end
  
  def print_coordinates(coordinates_array)
     coordinates_array.each do |coordinate|
       puts "coordinates for rectangle: #{coordinate}"
      end
  end
 end
 image = [
   [1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 0, 0, 0, 1],
  [1, 0, 1, 0, 0, 0, 1],
  [1, 0, 1, 1, 1, 1, 1],
  [1, 0, 1, 0, 0, 1, 1],
  [1, 1, 1, 0, 0, 1, 1],
  [1, 1, 1, 1, 1, 1, 1],
]

  box_image = BoxImage.new(image)
  box_image.find_boxes 2
